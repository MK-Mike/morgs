This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
_seed/
  headlands/
    page.tsx
  routes/
    page.tsx
  sectors/
    page.tsx
(with-sidebar)/
  about/
    page.tsx
  accommodation/
    page.tsx
  activities/
    page.tsx
  environment-ethics/
    page.tsx
  search-results/
    page.tsx
  sectors/
    [sector]/
      [route]/
        page.tsx
      page.tsx
    layout.tsx
    page.tsx
    sector-loading.tsx
  layout.tsx
  loading.tsx
account/
  layout.tsx
  page.tsx
layout.tsx
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="_seed/headlands/page.tsx">
"use client";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import routesData from "~/data/routes.json";
import { Button } from "~/components/ui/button";
import {
  createHeadland,
  getAllHeadlands,
  updateHeadlandAction,
} from "~/server/models/headlands";

import type { Headland as DBHeadland } from "@/server/models/headlands";
type Headland = {
  name: string;
  slug: string;
  description: string;
};
import { Suspense, useCallback, useEffect, useState } from "react";
import { EditHeadlandDialog } from "~/components/EditHeadlandDialog";

//map over the routes to get an array of headlands
const jsonHeadlands: Headland[] = [];
routesData.headlands.forEach((headland: Headland) =>
  jsonHeadlands.push({
    name: headland.name,
    slug: headland.slug,
    description: headland.description,
  }),
);
//get the headlands from the db
function DBHeadlandsTable() {
  const [dbHeadlands, setHeadlands] = useState<DBHeadland[]>([]);
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  // 2. Create a callback to update the trigger state
  const handleEditFinished = useCallback(() => {
    console.log("Edit finished, triggering refetch...");
    setRefreshTrigger((count) => count + 1); // Increment to trigger effect
  }, []); // useCallback ensures this function identity is stable]
  //use effect to fetch data from the db
  useEffect(() => {
    async function fetchData() {
      try {
        const data = await getAllHeadlands();
        setHeadlands(data);
      } catch (error) {
        console.error("Error fetching headlands from DB", error);
      }
    }
    void fetchData();
  }, [refreshTrigger]);

  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>id</TableHead>
          <TableHead>name</TableHead>
          <TableHead>slug</TableHead>
          <TableHead>Description</TableHead>
          <TableHead>Action </TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {dbHeadlands.map((headland: DBHeadland) => (
          <TableRow key={headland.slug}>
            <TableCell>{headland.id}</TableCell>
            <TableCell>{headland.name}</TableCell>
            <TableCell>{headland.slug}</TableCell>
            <TableCell>{headland.description}</TableCell>
            <TableCell>
              <EditHeadlandDialog
                headland={headland}
                onSaveAction={updateHeadlandAction}
                onFinishedAction={handleEditFinished}
              >
                <Button>Edit</Button>
              </EditHeadlandDialog>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}

//return a table of headlands from the db
function HeadlandsTable() {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [dbHeadlands, setHeadlands] = useState<DBHeadland[]>([]);
  //use effect to fetch data from the db
  useEffect(() => {
    async function fetchData() {
      try {
        const data = await getAllHeadlands();
        setHeadlands(data);
      } catch (error) {
        console.error("Error fetching headlands from DB", error);
      }
    }
    void fetchData();
  }, []);

  const handleAddClick = async (headlandData: Headland) => {
    setIsSubmitting(true);
    try {
      await createHeadland(headlandData);
      // Maybe add success feedback, e.g., re-fetch data or show a toast
      console.log("Headland added successfully!");
    } catch (error) {
      console.error("Failed to add headland:", error);
      // Show error feedback to the user
    } finally {
      setIsSubmitting(false);
    }
  };
  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>name</TableHead>
          <TableHead>slug</TableHead>
          <TableHead>Description</TableHead>
          <TableHead>Action </TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {jsonHeadlands.map((headland: DBHeadland) => (
          <TableRow key={headland.slug}>
            <TableCell>{headland.name}</TableCell>
            <TableCell>{headland.slug}</TableCell>
            <TableCell>{headland.description}</TableCell>
            <TableCell>
              {/* Check if the headland exists in the db */}
              {dbHeadlands.find(
                (dbHeadland) => dbHeadland.slug === headland.slug,
              ) ? (
                ""
              ) : (
                <Button
                  onClick={() =>
                    handleAddClick({
                      name: headland.name,
                      slug: headland.slug,
                      description: headland.description,
                    })
                  }
                  className="rounded bg-blue-500 px-4 py-2 font-bold text-white hover:bg-blue-700"
                  type="button"
                  disabled={isSubmitting}
                >
                  {isSubmitting ? "Adding..." : "Add"}
                </Button>
              )}
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
}

export default function SeedSectorPage() {
  return (
    <div>
      <h1 className="text-5xl font-bold">Seed Headlands </h1>
      <div className="mb-4 text-2xl">
        <h2 className="mt-4">Headlands From routes.json</h2>
        <HeadlandsTable />
      </div>
      <div className="mb-4 text-2xl">
        <h2 className="mt-4">Edit Headland</h2>
        <Suspense fallback={<div>Loading...</div>}>
          <DBHeadlandsTable />
        </Suspense>
      </div>
    </div>
  );
}
</file>

<file path="_seed/routes/page.tsx">
"use client";
import type {
  Headland as DataHeadland,
  Route,
  Sector,
} from "@/app/types/routes"; // Renamed to avoid clash
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import routesData from "~/data/routes.json";
import { Button } from "~/components/ui/button";

import { getAllSectors } from "~/server/models/sectors";
import type { SectorMetaData } from "@/server/models/sectors";
import { createRoute, getRouteSlugs } from "@/server/models/routes";
import type { DBRouteData } from "@/server/models/routes";
import { useState, useEffect } from "react";

const infoMap = new Map<string, string>();
infoMap.set(null, "-");
infoMap.set("T, A0", "trad");
infoMap.set("T&1RB", "trad");
infoMap.set("T&2RB", "trad");
infoMap.set("1RB&T", "trad");
infoMap.set("4RB&T, A0", "trad");
infoMap.set("T & 5RB", "trad");
infoMap.set("A0 T", "trad");
infoMap.set("(T)", "trad");
infoMap.set("(S)", "solo");
infoMap.set("(Solo)", "solo");
infoMap.set("(5B&C)", "sport");
infoMap.set("(4RB&T)", "trad");
infoMap.set("(8B&C)", "sport");
infoMap.set("(C only)", "trad");
infoMap.set("T", "trad");
infoMap.set("S", "sport");
infoMap.set("solo", "solo");

export default function SeedSectorPage() {
  const [allSectors, setAllSectors] = useState<SectorMetaData[]>([]);
  const [allRoutes, setAllRoutes] = useState<DBRouteData[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [isCreating, setIsCreating] = useState<boolean>(false);
  const [numRoutesAdded, setNumRoutesAdded] = useState<number>(0);
  const [error, setError] = useState<string | null>(null);
  const [routeSlugs, setRouteSlugs] = useState<string[]>([]);

  // Effect for fetching sectors
  useEffect(() => {
    const fetchSectors = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const sectorsData = await getAllSectors();
        setAllSectors(sectorsData);
      } catch (err) {
        console.error("Failed to fetch sectors:", err);
        setError("Could not load sectors. Bit awkward.");
      } finally {
        setIsLoading(false);
      }
    };

    void fetchSectors();
  }, []);

  // Effect for fetching route slugs
  useEffect(() => {
    const fetchRouteSlugs = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const dbRouteSlugs = await getRouteSlugs();
        const slugArray: string[] = dbRouteSlugs.flatMap(
          (result) => result.slug,
        );
        console.log("Slugs:", slugArray);
        setRouteSlugs(slugArray);
      } catch (err) {
        console.error("Failed to fetch route slugs:", err);
        setError("Could not load route slugs. Bit awkward.");
      } finally {
        setIsLoading(false);
      }
    };

    void fetchRouteSlugs();
  }, [allSectors]);

  // Effect for processing routes once sectors are fetched
  useEffect(() => {
    if (allSectors.length === 0) {
      return;
    }

    const sectorsIDMap = new Map<string, number>();
    allSectors.forEach((sector) => {
      sectorsIDMap.set(sector.slug, sector.id);
    });

    const processedRoutes: DBRouteData[] = [];
    routesData.headlands.forEach((headland: DataHeadland) => {
      headland.sectors.forEach((sector: Sector) => {
        const sectorId = sectorsIDMap.get(sector.slug);
        sector.routes.forEach((route: Route) => {
          if (routeSlugs.includes(route.slug)) {
            console.log("Skipping route", route.slug);
            return;
          }
          processedRoutes.push({
            slug: route.slug,
            name: route.name,
            routeNumber: route.routeNumber,
            grade: route.grade,
            stars: route.stars,
            description: route.description,
            firstAscent: route.first_ascent,
            date: route.date === "n/a" ? "" : route.date,
            info: route.info,
            routeStyle: infoMap.get(route.info) ?? "-",
            sectorId: sectorId,
          } satisfies DBRouteData);
        });
      });
    });
    const infoArray = new Set<string>(
      processedRoutes.map((route) => route.info),
    );
    console.log("Info Array:", infoArray);

    setAllRoutes(processedRoutes);
  }, [allSectors, routeSlugs]);

  const handleAddAllClick = async () => {
    setIsCreating(true);
    // Reset count if needed, or rely on parent component state logic
    // setNumRoutesAdded(0); // Optional: Reset count at the start of a batch

    if (allRoutes.length === 0) {
      console.log("No routes to add.");
      setIsCreating(false);
      return;
    }

    console.log(`Starting to add ${allRoutes.length} routes...`);

    // Create an array to track completion of each operation
    const promises = allRoutes.map((route) => {
      // Prepare data for this specific route
      const preparedRoute = {
        ...route,
        description: route.description ?? " ",
        date: new Date(route.date),
        routeStyle:
          route.routeStyle === "-" ? infoMap.get(route.info) : route.routeStyle,
      };

      // Return the promise chain for this single route
      return createRoute(preparedRoute)
        .then(() => {
          // Success for *this* route
          console.log(`Successfully added route: ${preparedRoute.name}`);
          // Update state immediately using functional update
          setNumRoutesAdded((prevCount) => prevCount + 1);
        })
        .catch((err) => {
          // Failure for *this* route
          console.error(
            `Failed to add route: ${preparedRoute.name}. Reason:`,
            err,
          );
          // Optionally: update a separate error count state?
          // setErrorCount(prev => prev + 1);

          // Important: Catch the error here so Promise.allSettled below
          // doesn't see it as an unhandled rejection for *this specific operation*.
          // We've handled it by logging.
        });
    });

    // Use Promise.allSettled just to know when everything is done
    try {
      await Promise.allSettled(promises);
      console.log("Finished processing all route requests.");
      // Add final user feedback if desired (e.g., based on final count vs total)
    } catch (err) {
      // Should be unlikely to hit this specific catch block now,
      // as individual errors are caught above.
      console.error("An unexpected error occurred while waiting:", err);
    } finally {
      // Ensure loading state is turned off once all promises have settled
      setIsCreating(false);
    }
  };
  // Display loading or error states
  if (isLoading) {
    return <div>Loading sectors... Stand by.</div>;
  }

  if (error) {
    return <div className="text-red-600">{error}</div>;
  }

  // --- Inline Table Components ---
  // Simpler to define them here now they rely on state

  const RoutesTable = () => (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Name</TableHead>
          <TableHead>Slug</TableHead>
          <TableHead>Route No.</TableHead>
          <TableHead>Grade</TableHead>
          <TableHead>Stars</TableHead>
          <TableHead>Description</TableHead>
          <TableHead>First Ascent</TableHead>
          <TableHead>Date</TableHead>
          <TableHead>Info</TableHead>
          <TableHead>Style</TableHead>
          <TableHead>Sector ID</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {allRoutes.map((route: DBRouteData) => (
          <TableRow key={`${route.slug}-${route.routeNumber}`}>
            <TableCell>{route.name}</TableCell>
            <TableCell>{route.slug}</TableCell>
            <TableCell>{route.routeNumber}</TableCell>
            <TableCell>{route.grade}</TableCell>
            <TableCell>{route.stars ?? "N/A"}</TableCell>{" "}
            {/* Handle null stars */}
            <TableCell>{route.description}</TableCell>
            <TableCell>{route.firstAscent}</TableCell>
            <TableCell>{`${route.date}`}</TableCell> {/* Format date */}
            <TableCell>{route.info}</TableCell>
            <TableCell>{route.routeStyle}</TableCell>
            <TableCell>{route.sectorId}</TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );

  // --- Render ---
  return (
    <div>
      <h1 className="text-5xl font-bold">Seed Sectors</h1>
      <div>
        <div className="justify-bewteen flex w-full flex-row items-center">
          <h2 className="mt-4 text-2xl">Routes from Data</h2>
          <Button onClick={handleAddAllClick} className="ml-4">
            {isCreating
              ? `Working...(${numRoutesAdded}/${allRoutes.length})`
              : `Add All (${allRoutes.length})`}
          </Button>
        </div>
        <RoutesTable />
      </div>
    </div>
  );
}
</file>

<file path="_seed/sectors/page.tsx">
"use client";
import type { Headland as DataHeadland, Sector } from "@/app/types/routes"; // Renamed to avoid clash
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import routesData from "~/data/routes.json";
import { Button } from "~/components/ui/button";

import type { Headland as DBHeadland } from "@/server/models/headlands"; // Keep this type
import { getAllHeadlands } from "~/server/models/headlands"; // Import the fetch function
import type { SectorData } from "@/server/models/sectors";
import { createSector } from "@/server/models/sectors";
import { useState, useEffect } from "react"; // Import hooks

export default function SeedSectorPage() {
  const [dbHeadlands, setDbHeadlands] = useState<DBHeadland[]>([]);
  const [allSectors, setAllSectors] = useState<SectorData[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // Effect for fetching headlands
  useEffect(() => {
    const fetchHeadlands = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const headlandsData = await getAllHeadlands();
        setDbHeadlands(headlandsData);
      } catch (err) {
        console.error("Failed to fetch headlands:", err);
        setError("Could not load headlands. Bit awkward.");
      } finally {
        setIsLoading(false);
      }
    };

    void fetchHeadlands();
  }, []); // Empty dependency array means run once on mount

  // Effect for processing sectors once headlands are fetched
  useEffect(() => {
    if (dbHeadlands.length === 0) {
      // Don't process if headlands aren't loaded yet
      setAllSectors([]); // Ensure sectors are cleared if headlands change/reload
      return;
    }

    const headlandIdMap = new Map<string, number>();
    dbHeadlands.forEach((headland) => {
      headlandIdMap.set(headland.slug, headland.id);
    });

    const processedSectors: SectorData[] = [];
    routesData.headlands.forEach((headland: DataHeadland) => {
      headland.sectors.forEach((sector: Sector) => {
        const headlandId = headlandIdMap.get(headland.slug);
        if (headlandId === undefined) {
          console.warn(
            `Headland slug "${headland.slug}" not found in DB headlands for sector "${sector.name}". Skipping.`,
          );
          return; // Skip if no matching headland ID found
        }
        const sectorData: SectorData = {
          name: sector.name,
          slug: sector.slug,
          description: sector.description,
          headlandId: headlandId,
          // headlandSlug: headland.slug, // Add if needed in SectorData type
        };
        processedSectors.push(sectorData);
      });
    });

    setAllSectors(processedSectors);
  }, [dbHeadlands]); // Re-run this effect if dbHeadlands changes

  const handleAddAllClick = async () => {
    if (allSectors.length === 0) {
      console.log("No sectors to add.");
      return;
    }
    console.log(`Adding ${allSectors.length} sectors...`);
    // Consider adding some feedback for success/failure here
    try {
      // Using Promise.all for potentially better performance if createSector is truly async
      await Promise.all(
        allSectors.map((sector) => {
          console.log("Adding sector", sector.name);
          return createSector(sector); // Assuming createSector returns a Promise
        }),
      );
      console.log("All sectors added (hopefully).");
      // Maybe add a success message to the user
    } catch (err) {
      console.error("Failed to add one or more sectors:", err);
      // Maybe add an error message to the user
    }
  };

  // Display loading or error states
  if (isLoading) {
    return <div>Loading headlands... Stand by.</div>;
  }

  if (error) {
    return <div className="text-red-600">{error}</div>;
  }

  // --- Inline Table Components ---
  // Simpler to define them here now they rely on state

  const HeadlandsTable = () => (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>id</TableHead>
          <TableHead>name</TableHead>
          <TableHead>slug</TableHead>
          <TableHead>Description</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {dbHeadlands.map((headland) => (
          <TableRow key={headland.slug}>
            <TableCell>{headland.id}</TableCell>
            <TableCell>{headland.name}</TableCell>
            <TableCell>{headland.slug}</TableCell>
            <TableCell>{headland.description}</TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );

  const SectorsTable = () => (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>name</TableHead>
          <TableHead>slug</TableHead>
          {/* <TableHead>headland slug</TableHead> */}
          {/* Removed headland slug unless you add it back to SectorData */}
          <TableHead>headland id</TableHead>
          <TableHead>description</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {allSectors.map((sector) => (
          <TableRow key={sector.slug}>
            <TableCell>{sector.name}</TableCell>
            <TableCell>{sector.slug}</TableCell>
            {/* <TableCell>{sector.headlandSlug}</TableCell> */}
            <TableCell>{sector.headlandId}</TableCell>
            <TableCell>{sector.description}</TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );

  // --- Render ---
  return (
    <div>
      <h1 className="text-5xl font-bold">Seed Sectors</h1>
      <div className="mb-4 text-2xl">
        <h2 className="mt-4">Headlands From DB</h2>
        <HeadlandsTable />
      </div>
      <div>
        <div className="justify-bewteen flex w-full flex-row items-center">
          {" "}
          {/* Added items-center */}
          <h2 className="mt-4 text-2xl">Sectors from Data</h2>
          <Button onClick={handleAddAllClick} className="ml-4">
            {" "}
            {/* Added margin */}
            Add All ({allSectors.length})
          </Button>
        </div>
        <SectorsTable />
      </div>
    </div>
  );
}
</file>

<file path="(with-sidebar)/about/page.tsx">
import Link from "next/link";
import Breadcrumbs from "~/components/Breadcrumbs";

export default function AboutPage() {
  return (
    <div className="container mx-auto max-w-5xl px-4 py-8">
      <Breadcrumbs />
      <h1 className="mb-6 text-3xl font-bold">About Morgan Bay Climbing</h1>
      <div className="space-y-6">
        <p>
          {`Morgan Bay is South Africa's only developed sea cliff climbing area,
          offering a unique blend of traditional climbing routes set against the
          backdrop of the stunning Eastern Cape coastline. With over 600 trad
          lines and a handful of sport routes(all of which are currently in the
          process of being re-bolted with Titanium glue-ins thanks to the huge
          donations from Gavin Voorwerg and ongoing work by Willem Van der Spuy
          of Morgan bay Adventures), Morgan Bay provides a diverse range of
          climbing experiences for enthusiasts of all levels.`}
        </p>
        <p>
          {`The climbing is spread across 5 headlands, each with its own character
          and challenges. From wave-cut platforms and sheer cliffs to spires and
          stacks of Dolerite, climbers can enjoy a variety of climbing styles on
          differing formations. There's something for every style of climber
          including off-widths and splitter cracks, slabs and crimpy faces, and
          not to mention some shorter multi-pitch routes, Morgs has everything
          you could think to ask for in a climbing destination.`}
        </p>
        <h2 className="mb-2 mt-4 text-2xl font-semibold">
          Best Seasons for Climbing
        </h2>
        <p>
          {`Morgan Bay offers year-round climbing opportunities. With the driest
          months being from May to August. When low rainfall and mild
          temperatures combine, the winter months are the best time to plan a
          trip to avoid the rain. Summer's (December to February) are generally
          hot in the mornings, with cool refreshing ocean breezes picking up
          early afternoon and cooling the crags make climbing comfortable.
          Unfortunately, summer is also the wet season with rains falling about
          40% of the time. The rock dries fairly fast after a drizzle but may
          take up to a day or two to dry sufficiently to climb if there have
          been a few days of rain.`}
        </p>
        <h2 className="mb-2 mt-4 text-2xl font-semibold">History</h2>
        <p>
          Climbing in Morgan Bay has a rich history dating back several decades.
          Pioneers like Dave and Barbara Freer opened many of the prominent trad
          lines in the 1980s and 90s with Derek the monster Marshall, Allan
          Luck, Craig Bester, Gavin Peckham, Ruben Snyman, Tyson Baars, Garvin
          Jacobs and Dirk van der Walt all having opened multiple new routes
          since then. Continuous development by local and visiting climbers has
          expanded the number and variety of routes available and turned Morgan
          bay into the premier climbing destination that it is today.
        </p>
        <h2 className="mb-2 mt-4 text-2xl font-semibold">
          Access and Logistics
        </h2>
        <p>
          Morgan Bay is located about 90 km from East London towards Mthatha on
          the N2. Most climbing areas are accessible via short walks from
          parking areas on top of the headlands. Some sectors (such as the
          wave-cut platforms and sea stacks) require low tide and calm sea
          conditions for safe access. Always check tide tables and weather
          forecasts before planning your climbs.
        </p>
        <p>
          There is a small shop in Morgan Bay for provisions should you have
          forgotten any of the necessities, as well as a larger more suitably
          stocked Savemore in Kei Mouth, the next village over. Kei Mouth also
          has a petrol station.
        </p>
        <h2 className="mb-2 mt-4 text-2xl font-semibold text-sky-400">
          Acknowldgements
        </h2>
        <p className="text-sky-100">
          This project is only possible because of the hard work and time put in
          by Derek “The Monster” Marshal (legend of Eastern Cape Climbing) who
          was the first person to put together an amalgamated climbing guide for
          Morgan Bay. Basing his work off of MCSA climbing journals and his
          wealth of hands-on experience in the area, the majority of the
          development in Morgan bay is due to his unwavering efforts and love
          for the area and the sport of outdoor climbing. We are deeply thankful
          for his time and effort.
        </p>
        <p>
          Further acknowledgement needs to be made to Mike Kent, who did the
          majority of the leg work for this guide and whose passion for the
          sport of climbing is matched only by his stoke to explore and find new
          places to climb in the Transkei.
        </p>
        <h2 className="mb-2 mt-4 text-2xl font-semibold">Useful Links</h2>
        <div>
          {`Here's a list of websites which may be helpful in planning your trip:`}
          <p className="mt-2">
            <Link href="https://morganbay.co.za/" target="_blank">
              https://morganbay.co.za/
            </Link>
          </p>
          <p className="mt-2">
            <Link href="https://www.morganbayadventures.co.za/" target="_blank">
              https://www.morganbayadventures.co.za/
            </Link>
          </p>
          <p className="mt-2">
            <Link
              href="https://www.easterncaperockclimbing.co.za/"
              target="_blank"
            >
              https://www.easterncaperockclimbing.co.za/
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="(with-sidebar)/accommodation/page.tsx">
import Breadcrumbs from "~/components/Breadcrumbs";
import Link from "next/link";

export default function AccommodationPage() {
  return (
    <div className="container mx-auto max-w-screen-xl px-4 py-8">
      <Breadcrumbs />
      <h1 className="mb-6 text-3xl font-bold">Accommodation</h1>
      <div className="space-y-6">
        <div>
          <h2 className="mb-2 text-2xl font-semibold">Morgan Bay Hotel</h2>
          <p>
            Offers a variety of accommodation options and includes The Deck, a
            restaurant with good food and cold beer. Ideal for families.
          </p>
          <p>
            Contact: 043-8411062 |{" "}
            <Link
              href="mailto:info@morganbayhotel.co.za"
              className="text-blue-500 hover:underline"
            >
              info@morganbayhotel.co.za
            </Link>{" "}
            |{" "}
            <Link
              href="https://morganbayhotel.co.za"
              target="_blank"
              rel="noopener noreferrer"
              className="text-blue-500 hover:underline"
            >
              morganbayhotel.co.za
            </Link>
          </p>
        </div>
        <div>
          <h2 className="mb-2 text-2xl font-semibold">
            Double Mouth Nature Reserve
          </h2>
          <p>
            Offers camping on the beach. Facilities are basic but the location
            is beautiful. Booking recommended during peak seasons.
          </p>
          <p>Contact: 043 736 9909</p>
        </div>
        <div>
          <h2 className="mb-2 text-2xl font-semibold">Morgan Bay Camp Site</h2>
          <p>
            Camping next to the lagoon and close to the beach. Great for
            families.
          </p>
          <p>Bookings through Morgan Bay Hotel</p>
        </div>
        <div>
          <h2 className="mb-2 text-2xl font-semibold">Yellowwood Forest</h2>
          <p>
            Offers camping, cottages, and a backpackers in a natural forest
            setting. Has a coffee shop and restaurant with great pizza during
            high season.
          </p>
          <p>
            Contact: 043-8411598 |{" "}
            <Link
              href="mailto:info@yellowwoodforest.co.za"
              className="text-blue-500 hover:underline"
            >
              info@yellowwoodforest.co.za
            </Link>{" "}
            |{" "}
            <Link
              href="https://www.yellowwoodforest.co.za"
              target="_blank"
              rel="noopener noreferrer"
              className="text-blue-500 hover:underline"
            >
              yellowwoodforest.co.za
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="(with-sidebar)/activities/page.tsx">
import Breadcrumbs from "~/components/Breadcrumbs"

export default function ActivitiesPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <Breadcrumbs />
      <h1 className="text-3xl font-bold mb-6">Activities in Morgan Bay</h1>
      <div className="space-y-6">
        <div>
          <h2 className="text-2xl font-semibold mb-2">Beach Activities</h2>
          <p>
            Morgan Bay boasts a beautiful beach perfect for swimming, surfing, and long walks. The estuary is great for
            kids to play and swim safely.
          </p>
        </div>
        <div>
          <h2 className="text-2xl font-semibold mb-2">Fishing</h2>
          <p>
            Excellent bass fishing is available in the local dam. The estuary and sea shore also offer great fishing
            opportunities with a variety of species.
          </p>
        </div>
        <div>
          <h2 className="text-2xl font-semibold mb-2">Hiking</h2>
          <p>
            There are numerous hiking trails in the area, offering beautiful coastal views and opportunities for bird
            watching and wildlife spotting.
          </p>
        </div>
        <div>
          <h2 className="text-2xl font-semibold mb-2">Nature and Wildlife</h2>
          <p>
            The area is rich in biodiversity. Bird watching is popular, and you might spot dolphins frolicking in the
            waves from the cliffs.
          </p>
        </div>
        <div>
          <h2 className="text-2xl font-semibold mb-2">Photography</h2>
          <p>
            The dramatic sea cliffs, beautiful beach, and diverse wildlife offer endless opportunities for photography
            enthusiasts.
          </p>
        </div>
        <div>
          <h2 className="text-2xl font-semibold mb-2">Nearby Attractions</h2>
          <p>
            The nearby town of Kei Mouth offers additional amenities and attractions. The area is also rich in cultural
            history, with opportunities to learn about local Xhosa culture.
          </p>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="(with-sidebar)/environment-ethics/page.tsx">
import Breadcrumbs from "~/components/Breadcrumbs"

export default function EnvironmentEthicsPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <Breadcrumbs />
      <h1 className="text-3xl font-bold mb-6">Environment & Ethics</h1>
      <div className="space-y-6">
        <h2 className="text-2xl font-semibold mt-4 mb-2">Local Ecosystem</h2>
        <p>
          Morgan Bay is home to a diverse coastal ecosystem, featuring unique flora and fauna adapted to the sea cliff
          environment. The area is characterized by dolerite cliffs set on shale bands, creating a varied and
          interesting geological landscape.
        </p>
        <h2 className="text-2xl font-semibold mt-4 mb-2">Environmental Impact</h2>
        <ul className="list-disc pl-6 space-y-2">
          <li>Stay on established trails and avoid creating new paths to minimize erosion.</li>
          <li>Pack out all trash, including organic waste.</li>
          <li>Respect wildlife and plant life. Avoid disturbing nesting birds or damaging vegetation.</li>
          <li>Use existing anchors where available and minimize the placement of new fixed gear.</li>
        </ul>
        <h2 className="text-2xl font-semibold mt-4 mb-2">Access and Respect</h2>
        <p>
          While many climbing areas are on public land, some may cross private property. Always respect landowners'
          rights and any posted signs or restrictions. Be courteous to local residents and other visitors.
        </p>
        <h2 className="text-2xl font-semibold mt-4 mb-2">Safety Considerations</h2>
        <ul className="list-disc pl-6 space-y-2">
          <li>Be aware of tide times and sea conditions, especially when climbing on lower sections.</li>
          <li>Watch for loose rock and always wear a helmet.</li>
          <li>Be cautious of slippery grass when approaching crags, especially when wet.</li>
          <li>Bring adequate water and sun protection.</li>
        </ul>
      </div>
    </div>
  )
}
</file>

<file path="(with-sidebar)/search-results/page.tsx">
"use client";
import { Suspense } from "react";
import { useSearchParams } from "next/navigation";
import Link from "next/link";
import { useState, useEffect } from "react";
import routesData from "@/data/routes.json"; // Import your data file

interface Route {
  slug: string;
  name: string;
  grade: number;
  length?: number;
  description: string;
  sector: string;
  sectorSlug: string;
  headland: string;
}

interface Sector {
  slug: string;
  name: string;
  description: string;
  headland: string;
}

interface SearchResults {
  matchedRoutes: Route[];
  matchedSectors: Sector[];
}

function SearchResultsComponent() {
  const searchParams = useSearchParams();
  const [results, setResults] = useState<SearchResults>({
    matchedRoutes: [],
    matchedSectors: [],
  });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const queryTerm = searchParams.get("q") || "";

  // Inside your component:
  useEffect(() => {
    const searchLocalData = () => {
      try {
        setIsLoading(true);

        // If no query term, return empty results
        if (!queryTerm) {
          setResults({ matchedRoutes: [], matchedSectors: [] });
          return;
        }

        const lowerCaseTerm = queryTerm.toLowerCase();
        const searchResults: SearchResults = {
          matchedRoutes: [],
          matchedSectors: [],
        };

        // Search through headlands, sectors, and routes
        routesData.headlands.forEach((headland) => {
          headland.sectors.forEach((sector) => {
            // Check if sector matches
            if (sector.name.toLowerCase().includes(lowerCaseTerm)) {
              searchResults.matchedSectors.push({
                name: sector.name,
                description: sector.description,
                headland: headland.name,
                slug: sector.slug,
              });
            }

            // Search through routes in the sector
            sector.routes.forEach((route) => {
              if (route.name.toLowerCase().includes(lowerCaseTerm)) {
                searchResults.matchedRoutes.push({
                  name: route.name,
                  grade: route.grade,
                  length: route.length, // Assuming length is part of the route data
                  description: route.description,
                  sector: sector.name,
                  sectorSlug: sector.slug,
                  headland: headland.name,
                  slug: route.slug,
                });
              }
            });
          });
        });

        setResults(searchResults);
        console.log(searchResults);
      } catch (err) {
        console.error("Error searching data:", err);
        setError("Failed to search routes data. Please try again.");
      } finally {
        setIsLoading(false);
      }
    };

    searchLocalData();
  }, [queryTerm]);

  if (isLoading) {
    return (
      <div className="container mx-auto flex min-h-[200px] items-center justify-center p-4">
        <div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="container mx-auto p-4">
        <div className="rounded border border-red-400 bg-red-100 px-4 py-3 text-red-700">
          <p>{error}</p>
        </div>
      </div>
    );
  }

  const totalResults =
    results.matchedRoutes.length + results.matchedSectors.length;

  return (
    <div className="container mx-auto p-4">
      <h2 className="mb-4 text-2xl font-bold">
        Results {queryTerm && <span>for "{queryTerm}"</span>}
      </h2>
      {totalResults === 0 && !isLoading ? (
        <div className="rounded-lg bg-gray-100 p-6 text-center">
          <h2 className="mb-2 text-xl">No results found</h2>
          <p className="text-gray-600">Try adjusting your search terms</p>
        </div>
      ) : (
        <>
          {results.matchedRoutes.length > 0 && (
            <section aria-labelledby="routes-heading">
              <h2
                id="routes-heading"
                className="mb-2 border-b pb-2 text-xl font-semibold"
              >
                Routes ({results.matchedRoutes.length})
              </h2>
              <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
                {results.matchedRoutes.map((route) => (
                  <div
                    key={route.slug}
                    className="rounded-lg border p-4 shadow-sm transition-shadow hover:shadow-md"
                  >
                    <h3 className="text-lg font-bold">{route.name}</h3>
                    <dl className="mt-2 grid grid-cols-2 gap-x-2">
                      <dt className="text-gray-600">Grade:</dt>
                      <dd>{route.grade}</dd>

                      {route.length && (
                        <>
                          <dt className="text-gray-600">Length:</dt>
                          <dd>{route.length} m</dd>
                        </>
                      )}

                      <dt className="text-gray-600">Sector:</dt>
                      <dd>{route.sector}</dd>

                      <dt className="text-gray-600">Headland:</dt>
                      <dd>{route.headland}</dd>
                    </dl>

                    {route.description && (
                      <div className="mt-2">
                        <p className="text-sm text-gray-600">
                          {route.description}
                        </p>
                      </div>
                    )}

                    <div className="mt-4">
                      <Link
                        href={`/sectors/${route.sectorSlug}/${route.slug}`}
                        className="font-medium text-cyan-800 hover:underline"
                      >
                        View Route Details
                      </Link>
                    </div>
                  </div>
                ))}
              </div>
            </section>
          )}

          {results.matchedSectors.length > 0 && (
            <section aria-labelledby="sectors-heading" className="mt-8">
              <h2
                id="sectors-heading"
                className="mb-2 border-b pb-2 text-xl font-semibold"
              >
                Sectors ({results.matchedSectors.length})
              </h2>
              <div className="grid gap-4 md:grid-cols-2">
                {results.matchedSectors.map((sector) => (
                  <div
                    key={sector.slug}
                    className="rounded-lg border p-4 shadow-sm transition-shadow hover:shadow-md"
                  >
                    <h3 className="text-lg font-bold">{sector.name}</h3>
                    <p className="mb-2 text-gray-600">
                      <strong>Headland:</strong> {sector.headland}
                    </p>

                    {sector.description && (
                      <div className="mb-4 mt-2">
                        <p className="text-sm text-gray-600">
                          {sector.description}
                        </p>
                      </div>
                    )}

                    <Link
                      href={`/sectors/${sector.slug}`}
                      className="font-medium text-blue-600 hover:underline"
                    >
                      View All Routes in This Sector
                    </Link>
                  </div>
                ))}
              </div>
            </section>
          )}
        </>
      )}
    </div>
  );
}

export default function SearchResultsPage() {
  return (
    <div className="container mx-auto p-4">
      <h1 className="mb-4 text-2xl font-bold">Search Results</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <SearchResultsComponent />
      </Suspense>
    </div>
  );
}
</file>

<file path="(with-sidebar)/sectors/[sector]/[route]/page.tsx">
"use client";

import { ChevronLeft, ChevronRight, Star } from "lucide-react";
import Image from "next/image";
import Link from "next/link";
import { notFound, useParams } from "next/navigation";
import { Suspense, useEffect, useState, useContext } from "react";
import Breadcrumbs from "~/components/Breadcrumbs";
import CommentsSection from "~/components/commentSection";
import DifficultyConsensus from "~/components/difficulty-consensus";
import RouteTags from "~/components/route-tags";
import { Button } from "~/components/ui/button";
import { Skeleton } from "~/components/ui/skeleton";
import type { Route } from "~/server/models/routes";
import { getRouteBySlug, getRoutesInSector } from "~/server/models/routes";
import { LoadingContext } from "~/contexts/sector-loading-context";

export default function RoutePage() {
  const { sector: sectorSlug, route: routeSlug } = useParams();
  const [isLoading, setIsLoading] = useState(true);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [route, setRoute] = useState<Route | undefined>(undefined);
  const [prevRoute, setPrevRoute] = useState<Route | null>(null);
  const [nextRoute, setNextRoute] = useState<Route | null>(null);
  const { setChildrenLoaded } = useContext(LoadingContext);
  const tags: string[] = ["pumpy", "technical"];
  if (!routeSlug) {
    notFound();
  }
  useEffect(() => {
    setChildrenLoaded(false);
    const fetchData = async () => {
      if (!routeSlug) return; // Guard clause

      setIsLoading(true);
      try {
        // Fetch the primary route
        const currentRoute: Route = await getRouteBySlug(String(routeSlug));
        setRoute(currentRoute);

        // Fetch other routes in the same sector after getting the sectorId
        const otherRoutes: Route[] = await getRoutesInSector(
          currentRoute.sectorId,
        );
        // Assuming server returns sorted data. If not, sort here:
        // const sortedRoutes = [...otherRoutes].sort((a, b) => a.routeNumber - b.routeNumber);
        const sortedRoutes = otherRoutes;

        const currentIndex = sortedRoutes.findIndex(
          (r) => r.slug === currentRoute.slug,
        );

        if (currentIndex !== -1) {
          setPrevRoute(
            currentIndex > 0 ? sortedRoutes[currentIndex - 1] : null,
          );
          setNextRoute(
            currentIndex < sortedRoutes.length - 1
              ? sortedRoutes[currentIndex + 1]
              : null,
          );
        }
      } catch (e) {
        console.error("Failed to fetch route data:", e);
        setIsLoading(false);
        notFound();
      } finally {
        setIsLoading(false);
        setChildrenLoaded(true);
      }
    };

    void fetchData();
  }, [routeSlug, setChildrenLoaded]);

  if (isLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div className="container mx-auto max-w-screen-xl px-4 py-4">
      <Breadcrumbs />
      <div className="mb-4 flex w-full justify-between">
        {prevRoute ? (
          <Button variant="outline" size="sm" asChild>
            <Link href={`/sectors/${String(sectorSlug)}/${prevRoute.slug}`}>
              <ChevronLeft className="mr-2 h-4 w-4" />
              Previous: {prevRoute.name}
            </Link>
          </Button>
        ) : (
          <Button variant="outline" size="sm" disabled>
            <ChevronLeft className="mr-2 h-4 w-4" />
            Previous: None
          </Button>
        )}

        {nextRoute ? (
          <Button variant="outline" size="sm" asChild>
            <Link href={`/sectors/${String(sectorSlug)}/${nextRoute.slug}`}>
              Next: {nextRoute.name}
              <ChevronRight className="ml-2 h-4 w-4" />
            </Link>
          </Button>
        ) : (
          <Button variant="outline" size="sm" disabled>
            Next: None
            <ChevronRight className="ml-2 h-4 w-4" />
          </Button>
        )}
      </div>
      <div className="grid grid-cols-1 gap-8 md:grid-cols-2">
        <div className="order-2 md:order-1">
          <div className="mb-3">
            <div className="flex items-center justify-between gap-3">
              <h1 className="text-3xl font-bold">{route.name}</h1>
              <div className="flex items-center gap-2">
                {route.stars ? (
                  <span className="flex">
                    {Array.from({ length: route.stars }).map((_, i) => (
                      <Star
                        key={i}
                        className="h-4 w-4 fill-yellow-400 text-yellow-400"
                      />
                    ))}
                  </span>
                ) : (
                  ""
                )}
                <span className="text-bg-secondary text-3xl font-bold">
                  {route.grade}
                </span>
              </div>
            </div>
            <span className="font-style:italic text-sm text-gray-400">
              {route.firstAscent} - {String(route.date)}
            </span>
          </div>
          <div className="space-y-4">
            <p>
              <strong>Style:</strong> {route.routeStyle}
            </p>
            <p>
              <strong>Info:</strong>{" "}
              {route.info?.replace("\(", "").replace("\)", "")}
            </p>
            <p>
              <strong>Description:</strong> {route.description}
            </p>
          </div>
          <div className="hidden w-full flex-col gap-4 pt-2 md:block">
            <RouteTags specifiedTags={tags} />
            <DifficultyConsensus />
          </div>
        </div>

        <div className="relative order-1 aspect-[3/4] w-full overflow-hidden rounded-lg bg-muted md:order-2">
          <Image
            src="/images/mockRoute.jpg"
            alt={`${route.name} route`}
            layout="fill"
            objectFit="cover"
            className={`transition-opacity duration-500 ${imageLoaded ? "opacity-100" : "opacity-0"}`}
            onLoad={() => setImageLoaded(true)}
          />
          {!imageLoaded && (
            <div className="absolute inset-0 flex items-center justify-center">
              <Skeleton className="h-[80%] w-[90%]" />
            </div>
          )}
        </div>

        <div className="order-3 col-span-1 md:col-span-2">
          <div className="flex w-full flex-col gap-2 md:hidden">
            <RouteTags specifiedTags={tags} />
            <DifficultyConsensus />
          </div>
          <Suspense fallback={<div>Loading comments...</div>}>
            <CommentsSection routeSlug={route.slug} />
          </Suspense>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="(with-sidebar)/sectors/[sector]/page.tsx">
"use client";
import { useEffect, useState, useContext } from "react";
import { notFound, useParams } from "next/navigation";
import Link from "next/link";
import Image from "next/image";
import { Input } from "~/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "~/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "~/components/ui/table";
import { Skeleton } from "~/components/ui/skeleton";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
  CardFooter,
} from "~/components/ui/card";
import Breadcrumbs from "~/components/Breadcrumbs";
import {
  Star,
  Route as RouteIcon,
  Mountain,
  MapPinCheckIcon,
} from "lucide-react";
import { Button } from "~/components/ui/button";
import { Badge } from "~/components/ui/badge";
import {
  DescriptionCardSkeleton,
  StatsCardSkeleton,
  ConditionsCardSkeleton,
  FiltersSkeleton,
  RoutesTableSkeleton,
  SectorImageSkeleton,
} from "~/components/sectorPage/sector-page-skeletons";
import { RoutesTable } from "~/components/sectorPage/sectorRouteTable";

import { getSectorBySlug } from "~/server/models/sectors";
import { getRoutesInSector } from "~/server/models/routes";
import type { SectorData as Sector } from "~/server/models/sectors";
import type { Route } from "~/server/models/routes";
import { LoadingContext } from "~/contexts/sector-loading-context";
import { useHeadlandAndSector } from "~/contexts/headland-sector-context";

//mapping for tag colours
const tagColours = new Map([
  ["pumpy", "emerald"],
  ["run out", "rose"],
  ["technical", "yellow"],
  ["slabby", "sky"],
  ["juggy", "pink"],
  ["crimpy", "emerald"],
  ["exposed", "rose"],
  ["vertical", "yellow"],
  ["overhang", "sky"],
  ["sustained", "pink"],
]);
export default function SectorPage() {
  const { sector: sectorSlug } = useParams();
  const [isLoading, setIsLoading] = useState(true);
  const [imageLoaded, setImageLoaded] = useState(false);
  const [sectorData, setSectorData] = useState<Sector | undefined>(undefined);
  const [sectorRoutes, setSectorRoutes] = useState<Route[] | undefined>(
    undefined,
  );
  const { headlands, sectors } = useHeadlandAndSector();

  const [minGrade, setMinGrade] = useState("");
  const [maxGrade, setMaxGrade] = useState("");
  const [routeStyle, setRouteStyle] = useState("all");
  const { setChildrenLoaded } = useContext(LoadingContext);

  const sectorName = sectors.find((s) => s.slug === sectorSlug)?.name;

  useEffect(() => {
    setChildrenLoaded(false);
    const fetchData = async () => {
      if (!sectorSlug) return; // Guard clause

      setIsLoading(true);
      try {
        // Fetch the primary sector data
        const currentSector: Sector = await getSectorBySlug(String(sectorSlug));
        setSectorData(currentSector);

        // Fetch the routes in this sector
        const routes: Route[] = await getRoutesInSector(currentSector.id);
        setSectorRoutes(routes);
        const minRouteGrade = Math.min(...routes.map((r) => r.grade));
        const maxRouteGrade = Math.max(...routes.map((r) => r.grade));
        setMinGrade(String(minRouteGrade));
        setMaxGrade(String(maxRouteGrade));
        setChildrenLoaded(true);
      } catch (e) {
        console.error("Failed to fetch sector data:", e);
        notFound();
      } finally {
        setIsLoading(false);
      }
    };
    void fetchData();
  }, [sectorSlug, setChildrenLoaded]);

  // if (isLoading) {
  //   return <div>Loading...</div>;
  // }

  if (!isLoading && !sectorData) {
    return <div>Sector not found</div>;
  }

  const tags = [];
  // });
  // Mock data for sector information (replace with actual data when available)
  const sectorInfo = {
    access:
      "15-minute walk from the parking area. Follow the marked trail heading east.",
    aspect: "South-facing",
    sun: "Gets sun from mid-morning to late afternoon. Shaded in early morning and evening.",
  };

  return (
    <div className="container mx-auto px-4 sm:px-6">
      <Breadcrumbs />
      <h1 className="mb-6 text-3xl font-bold">{sectorName} Sector</h1>
      <div className="mb-8 grid grid-cols-1 gap-4 sm:grid-cols-2 md:grid-cols-4">
        {/* Description and Access Card */}
        {isLoading ? (
          <DescriptionCardSkeleton />
        ) : (
          <Card className="flex flex-col items-center md:col-span-2 md:row-span-2">
            <CardHeader>
              <CardTitle>Description & Access</CardTitle>
            </CardHeader>
            <CardContent>
              <dl className="grid gap-2">
                <div>
                  <dt className="font-semibold">Description:</dt>
                  <dd>{sectorData.description}</dd>
                </div>
                <div>
                  <dt className="font-semibold">Access:</dt>
                  <dd>{sectorInfo.access}</dd>
                </div>
              </dl>
            </CardContent>
            <CardFooter className="w-full flex-1">
              <Button className="w-full" asChild>
                <Link
                  href={`https://www.google.com/maps/place/32%C2%B042'55.8%22S+28%C2%B019'55.0%22E/@-32.715512,28.331947,1011`}
                  target="_blank"
                >
                  <MapPinCheckIcon /> Take me there
                </Link>
              </Button>
            </CardFooter>
          </Card>
        )}

        {/* Total Routes Card */}
        {isLoading ? (
          <StatsCardSkeleton />
        ) : (
          <Card className="flex flex-col items-center justify-center p-4 text-center">
            <RouteIcon className="mb-2 h-8 w-8 text-primary" />
            <CardTitle className="text-4xl font-bold">
              {sectorRoutes.length}
            </CardTitle>
            <CardDescription>Total Routes</CardDescription>
          </Card>
        )}

        {/* Grade Range Card */}
        {isLoading ? (
          <StatsCardSkeleton />
        ) : (
          <Card className="flex flex-col items-center justify-center p-4 text-center">
            <Mountain className="mb-2 h-8 w-8 text-primary" />
            <CardTitle className="text-4xl font-bold">
              {minGrade} - {maxGrade}
            </CardTitle>
            <CardDescription>Grade Range</CardDescription>
          </Card>
        )}

        {/* Aspect and Sun Card */}
        {isLoading ? (
          <ConditionsCardSkeleton />
        ) : (
          <Card className="md:col-span-2 md:col-start-3">
            <CardHeader>
              <CardTitle>Climbing Conditions</CardTitle>
            </CardHeader>
            <CardContent>
              <dl className="grid gap-2">
                <div>
                  <dt className="font-semibold">Aspect:</dt>
                  <dd>{sectorInfo.aspect}</dd>
                </div>
                <div>
                  <dt className="font-semibold">Sun Exposure:</dt>
                  <dd>{sectorInfo.sun}</dd>
                </div>
              </dl>
            </CardContent>
          </Card>
        )}
      </div>

      {/* Image moved below all cards */}
      {isLoading ? (
        <SectorImageSkeleton />
      ) : (
        <div className="mb-8 w-full">
          <div className="relative aspect-video w-full overflow-hidden rounded-lg bg-muted">
            <Image
              src="/images/mockRoutes.jpg"
              alt={`${sectorData.name} sector`}
              layout="fill"
              objectFit="cover"
              className={`transition-opacity duration-500 ${imageLoaded ? "opacity-100" : "opacity-0"}`}
              onLoad={() => setImageLoaded(true)}
            />
            {!imageLoaded && (
              <div className="absolute inset-0 flex items-center justify-center">
                <Skeleton className="h-[80%] w-[90%]" />
              </div>
            )}
          </div>
        </div>
      )}

      <div className="space-y-4">
        <RoutesTable
          routes={sectorRoutes || []}
          sectorSlug={String(sectorSlug)}
          isLoading={isLoading}
        />
      </div>
    </div>
  );
}
</file>

<file path="(with-sidebar)/sectors/layout.tsx">
"use client";
import { useState } from "react";
import { ScrollArea } from "@/components/ui/scroll-area";
import { SiteFooter } from "~/components/site-footer";
import { LoadingContext } from "~/contexts/sector-loading-context";

export default function SectorsLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [childrenLoaded, setChildrenLoaded] = useState(false);

  return (
    <LoadingContext.Provider value={{ childrenLoaded, setChildrenLoaded }}>
      <div className="flex min-h-0 w-full flex-col">
        <ScrollArea className="flex-1 pb-32">
          {children}
          {childrenLoaded && <SiteFooter />}
        </ScrollArea>
      </div>
    </LoadingContext.Provider>
  );
}
</file>

<file path="(with-sidebar)/sectors/page.tsx">
"use client";
import { useState, useEffect } from "react";

import SectorCard from "~/components/SectorCard";
import Breadcrumbs from "~/components/Breadcrumbs";
import SkeletonCarousel from "~/components/SkeletonCarousel";
import AcknowledgementsModal from "~/components/AcknowledgementsModal";

import { useHeadlandAndSector } from "@/contexts/headland-sector-context";
async function waitFor(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
export default function SectorsPage() {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const { headlands, sectors } = useHeadlandAndSector();
  const orderedHeadlands = headlands.sort((a, b) =>
    a.name.slice(0, 1).localeCompare(b.name.slice(0, 1)),
  );
  useEffect(() => {
    try {
      const hasVisitedBefore = localStorage.getItem("hasVisitedSectorsPage");
      if (!hasVisitedBefore) {
        setIsModalOpen(true);
        localStorage.setItem("hasVisitedSectorsPage", "true");
      }
    } catch (error) {
      console.error("localStorage error:", error);
      setIsModalOpen(true);
    }
  }, []);

  useEffect(() => {
    const wait = async () => {
      await waitFor(1000);
      console.log("Waited for 1 second");
    };
    void wait();
  }, []);

  return (
    <div className="container mx-auto max-w-screen-xl px-4">
      <Breadcrumbs />
      <AcknowledgementsModal
        onOpenChange={setIsModalOpen}
        isOpen={isModalOpen}
      />

      <div className="mb-4">
        <h1 className="mb-2 text-3xl font-bold">Climbing Sectors</h1>
        <p className="text-muted-foreground">
          {sectors.length} sectors across {headlands.length} headlands
        </p>
      </div>

      <div className="mb-8 w-full overflow-hidden">
        <h2 className="mb-4 text-2xl font-semibold">Featured Routes</h2>
        <SkeletonCarousel />
      </div>

      {/* Group sectors by headland */}
      {orderedHeadlands.map((headland) => (
        <div key={headland.slug} className="mb-12 w-full">
          <h2 className="mb-6 text-2xl font-semibold">{headland.name}</h2>
          <div className="grid grid-cols-1 gap-4 sm:gap-6 md:grid-cols-2 lg:grid-cols-3">
            {sectors
              .filter((sector) => sector.headlandId === headland.id)
              .map((sector) => (
                <SectorCard
                  key={sector.slug}
                  name={sector.name}
                  slug={sector.slug}
                  gradeBuckets={sector.gradeBuckets}
                  routeTypes={sector.routeTypes}
                  // totalRoutes={sector.totalRoutes}
                />
              ))}
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="(with-sidebar)/sectors/sector-loading.tsx">
export default function SectorLoadingPage() {
  return (
    <div className="flex h-screen flex-col items-center justify-center">
      Sector Loading
    </div>
  );
}
</file>

<file path="(with-sidebar)/layout.tsx">
import type React from "react";
import Sidebar from "~/components/Sidebar";

export default function WithSidebarLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="flex h-[calc(100vh-56px)] overflow-y-hidden">
      <aside className="hidden lg:block lg:w-72 lg:flex-none">
        <Sidebar />
      </aside>
      <main className="flex-1 overflow-auto p-4">{children}</main>
    </div>
  );
}
</file>

<file path="(with-sidebar)/loading.tsx">
export default function Loading() {
  return <div>Loading page...</div>;
}
</file>

<file path="account/layout.tsx">
interface AppLayoutProps {
  children: React.ReactNode;
}

export default function AppLayout({ children }: AppLayoutProps) {
  return (
    <div
      data-wrapper=""
      className="border-grid flex w-full max-w-[100vw] flex-1 flex-col"
    >
      <main className="flex flex-1 flex-col">{children}</main>
    </div>
  );
}
</file>

<file path="account/page.tsx">
"use client";
import AccountPage from "@/components/account/account-page";

export default function Account() {
  return (
    <div className="container mx-auto max-w-screen-xl px-4">
      <AccountPage />
    </div>
  );
}
</file>

<file path="layout.tsx">
import { SiteHeader } from "@/components/site-header";
import { HeadlandAndSectorProvider } from "@/contexts/headland-sector-context";
import { getAllHeadlands } from "@/server/models/headlands";
import { getAllSectorsWithMetaData } from "@/server/models/sectors";

interface AppLayoutProps {
  children: React.ReactNode;
}

export default async function AppLayout({ children }: AppLayoutProps) {
  const headlands = await getAllHeadlands();
  const sectors = await getAllSectorsWithMetaData();

  return (
    <div
      data-wrapper=""
      className="border-grid flex w-full max-w-[100vw] flex-1 flex-col"
    >
      <HeadlandAndSectorProvider headlands={headlands} sectors={sectors}>
        <SiteHeader />
        <main className="flex flex-1 flex-col">{children}</main>
      </HeadlandAndSectorProvider>
    </div>
  );
}
</file>

</files>
